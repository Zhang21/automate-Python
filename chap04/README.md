# 列表

- 列表数据类型
    + 用下标取得某个列表中的单个值
    + 负数下标
    + 利用切片取得列表
    + 用len()取得列表长度
    + 用下标该表列表中的值
    + 列表连接和列表复制
    + 用del语句从列表中删除值
- 使用列表
    + 列表用于循环
    + in和not in操作符
    + 多重赋值技巧
- 增强的赋值操作
- 方法
    + 用index()方法在列表中查找值
    + 用append()和insert()方法在列表中添加值
    + 用remove()方法从列表中删除值
    + 用sort()方法将列表中的值排序
- 类似列表的类型： 字符串和元组
    + 可变和不可变数据类型
    + 元组数据类型
    + 用list()和tuple()函数来转换类型
- 引用
    + 传递引用
    + copy模块的copy()和decopy()函数


<br>

---

<br/>


## 列表数据类型

**列表**是一个值，它包含多个字构成的序列。列表用中括号`[]`括起，列表中的值称为**表项**，表项用逗号`,`隔开。

栗子： `[1, 'aa', ['a', 2, 'cc'], 'd']`，`[]`是一个空列表。

<br>

### 用下标取得列表中的单个值

列表的下标序号是从0开始的整数，`-1`可表示最后一个列表项。列表也可以包含其它列表值。

```py
spam = ['cat', 'bat', 123, ['windows', 'linux', 'unix'], 'zhang']

spam[0] ---> 'cat'
spam[-1] ---> 'zhang'
spam[3] ---> ['windows', 'linux', 'unix']
sapm[3][1] ---> 'linux'
```
<br>

### 列表负数下标

```py
spam = ['a', 'b', 333]

spam[-1] --> 333
spam[-2] --> 'b'

```

<br>

### 利用切片取得子列表

**切片**可从列表中取得多个值，结果是一个新列表。

在一个切片中，第一个整数是切片开始处的下标，第二个整数是切片结束处的下标，但不包括它。
你可以省略切片中冒号`:`两边的一个或两个下标。


```py
spam = [1, 'a', [22, 333], 'b']

spam[1:3] --> ['a', [22, 333]]
spam[1:-1] --> ['a', [22, 333]]
spam[:2] --> [1, 'a']
spam[1:] --> ['a', [22, 333], 'b']
apam[:] --> [1, 'a', [22, 333], 'b']

```

<br>

### 用len()取得列表长度

```py
spam = [ 1, 'a', 22]

len(spam)
#3

```

<br>

### 用下标改变列表中的值

```py
spam = [1, 'a', 22]

spam[0] = 111

```

<br>

### 列表连接和列表复制

`+`操作符可以连接两个列表，得到一个新列表。
`*`操作符可以用于一个列表和一个整数，实现列表的复制。

```py
[1, 2, 3] + ['a', 'b', 'c']
#[1, 2, 3, 'a', 'b', 'c']

spam = [1, 2, 3]
spamm = spam + ['a', 'b', 'c']

[1, 2, 3] * 3
#[1, 2, 3, 1, 2, 3, 1, 2, 3]

```

<br>

### 用del语句从列表中删除值

del语句将删除指定下标处的值，后面的值依次向前移动。
del语句也可以删除一个简单变量，也就是取消赋值。

```py
spam = [1, 'a', 2]

del spam[1]
#[1, 2]

```

<br>

---

<br/>


## 使用列表

不必使用多个重复的变量，你可以使用单个变量，包含一个列表值。

<br>

### 列表用于循环

```py
spam = [1, 'a', 2]
for i in range(len(spam)):
    print('spam[' + str(i) + '] is: ' + str(spam[i]))

```

<br>

### in和not in操作符

利用`in`和`not in`，可以确定一个值是否在列表中。

```py
'aa' in [1, 'aa', 2]
#True

spam = [1, 'aa', 2]
'A' not in spam
#True

```

<br>

### 多重赋值技巧

多重赋值技巧是一种快捷方式，让你在一行代码中，用列表中的值为多个变量赋值。

```py
#变量数目必须和列表长度一致
name = [1, 'aa', 'b']

var0, var1, var2 = name

```


<br>

---

<br/>


## 增强的赋值操作

针对`+`, `-`, `*`, `/`, `%`，都有增强的赋值操作符。

| 增强型 | 基础型
| - | -
| a += 1 | a = a+1
| a -= 1 | a = a-1
| a *= 1 | a = a*1
| a /= 1 | a = a/1
| a %= 1 | a = a%1

<br>

---

<br/>


## 方法

方法和函数是一回事，只是它是调用在一个值上。

<br>

### 用index()方法在列表中查找值

列表值有一个`index()`方法，可以传入一个值，如果该值存在于列表中，就返回它的下标，不在就报ValueError。
如果列表中存在重复的值，就返回它第一次出现的下标。

```py
spam = [1, 'a', 2]

spam.index('a')
#2

```

<br/>

### 用append()和insert()在列表中添加值

- `append()`方法调用，将参数添加到列表末尾
- `insert()`方法可以在列表任意下标处插入一个值。`insert()`方法第一个参数是新值的下标，第二个参数是插入的新值。
- `append()`和`insert()`方法只能在列表上调用，不能在其它值上调用(如字符串和整型)

```py
spam = [1, 'a', 2]

spam.append('b')
#[1, 'a', 2, 'b']

spam.insert(0, 'zhang')
#['zhang', 1, 'a', 2, 'b']

```
<br>

### 用remove()方法从列表中删除值

给`remove()`方法传入一个值，它将从被调用的列表中删除。
试图删除列表中不存在的值，将导致ValueError。
如果该值在列表中出现多次，只有第一次出现的值会被删除。

```py
spam = [1, 'a', 3, 1]

sapm.remove(1)
#['a', 3, 1]

```

<br>

### 用sort()方法将列表中的值排序

全数值或全字符串的列表，能用`sort()`排序。
不能对既有数字又有字符串值的列表排序，因为Python不知道如何比较它们。
默认是正序，也可指定关键字参数`reverse`为`True`来逆序排序。


```py
spam = [1, 3, -8, 4, 6]

spam.sort()
#[-8, 1, 3, 4, 6]

```


<br>

---

<br>


## 类似列表的类型：字符串和元组

字符串和列表实际上很相似，只要你认为字符串是单个文本字符的列表。
对列表的许多操作，也可用于字符串：按下标取值、切片、`for`循环、`len()`、`in` 和 `not in`。

```py
name = 'zhang'

name[0]
#'z'
name[-2]
#'n'
name[0:2]
#'zh'
'zh' in name
#True
'a' not in name
#False
for i in name:
    print('---' + i + '---')
#---z---
#...
#---g---

```

<br>

### 可变和不可变的数据类型

列表和字符串在一个重要的方面是不同的：

- 列表是**可变的**数据类型，它的值可以添加、删除或修改
- 字符串是**不可变的**，它不能被更改，你只能对它重新赋值

<br>

### 元组数据类型

除了以下两个方面，元组几乎与列表一样：

- 元组使用方括号`()`，列表使用中括号`[]`
- 元组和字符串一样，是不可变的。元组不能让它的值被修改、添加或删除

你可以使用元组告诉所有读代码的人，你不打算改变这个序列的值。如果需要一个永远不会改变的值的序列，就使用元组。这样Python可以实现一些优化，让使用元组的代码比使用列表更快。

```py
spam = (1, 'a', 2)

spam[0]
#1
spam[0:2]
#(1, 'a')

```

<br>

### 用list()和tuple()函数来转换类型

函数`list()`和`tuple()`将返回传递给它们的值的列表和元组版本。
如果需要元组值的一个可变版本，将元组转换成列表就很方便了。

```py
list((1, 'a', 3))
#[1, 'a', 3]

tuple([a, 'a', 3])
#(1, 'a', 3)

list('hello')
#['h', 'e', 'l', 'l', 'o']

```


<br>

---

<br/>


## 引用

当你将列表赋给一个变量时，实际上是将列表的**引用**赋给了该变量。引用一个值，指向某些数据。列表引用是指向上一个列表的值。

```py
#保存了对列表的引用，而非实际列表
spam = [0, 1, 2, 3]

#复制了引用，而非列表
chee = spam

#修改了两个变量指向的列表
chee[1] = 'a'

spam
#[0, 'a', 2, 3]
chee
#[0, 'a', 2, 3]

```

- 变量包含对列表值的引用，而非列表值本身
- 对于字符串和整数值，变量就包含了字符串和整数值
- 在变量必须保存可变数据类型的值时，如列表或字典，Python就使用引用
- 对于不可变的数据类型的值，如字符串、整型和元组，Python变量就保存值本身

**虽然Python变量在技术上包含了对列表或字典值的引用，但人们通常随意地说，该变量包含了列表或字典。**

**请记住这种行为：如果忘了Python处理列表和字典变量时采用这种方式，可能导致令人困惑的缺陷。**

<br>

### copy模块的copy()和deepcopy()函数

你可能不希望这些变动影响到原来的列表或字典，要做到这点，Python提供了`copy`模块。

- `copy()`函数，用来复制列表或字典的可变值，而不只是复制引用
- `deepcopy()`函数，用于复制列表中包含了列表

```py
import copy

spam = [0, 1, 2, 3]
chee = copy.copy(spam)
chee[1] = 'a'

spam
#[0, 1, 2, 3]
chee
#[0, 'a', 2, 3]

```





















































